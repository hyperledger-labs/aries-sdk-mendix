// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";

// BEGIN EXTRA CODE
import support from "../support/entidad";
import {
  ClaimFormat,
  JwaSignatureAlgorithm,
  Agent,
  KeyType,
  TypedArrayEncoder,
  W3cCredentialRecord,
  W3cCredentialsModule,
  DidKey,
} from '@aries-framework/core'
//import { OpenId4VpClientService, OpenIdCredentialFormatProfile } from '@internal/openid4vc-client'
// END EXTRA CODE

/**
 * https://github.com/hyperledger/aries-framework-javascript/tree/002be4f578729aed1c8ae337f3d2eeecce9e3725/packages/openid4vc-client
 * 
 * https://github.com/hyperledger/aries-framework-javascript/blob/002be4f578729aed1c8ae337f3d2eeecce9e3725/packages/openid4vc-client/src/OpenId4VcClientApi.ts#L26
 * 
 * 
 *   public async requestCredentialUsingPreAuthorizedCode(
 *     options: PreAuthCodeFlowOptions
 *   ): Promise<W3cCredentialRecord[]> {
 *     // set defaults
 *     const verifyRevocationState = options.verifyCredentialStatus ?? true
 * 
 *     return this.openId4VcClientService.requestCredential(this.agentContext, {
 *       ...options,
 *       verifyCredentialStatus: verifyRevocationState,
 *       flowType: AuthFlowType.PreAuthorizedCodeFlow,
 *     })
 *   }
 * 
 * 
 * https://github.com/hyperledger/aries-framework-javascript/blob/002be4f578729aed1c8ae337f3d2eeecce9e3725/packages/openid4vc-client/src/OpenId4VcClientServiceOptions.ts#L14
 * 
 * 
 * /////
 *  // Options that are used for the pre-authorized code flow.
 *  ///
 * export interface PreAuthCodeFlowOptions {
 *   issuerUri: string
 *   verifyCredentialStatus: boolean
 * 
 *   /////
 *    // A list of allowed credential formats in order of preference.
 *    //
 *    // If the issuer supports one of the allowed formats, that first format that is supported
 *    // from the list will be used.
 *    //
 *    // If the issuer doesn't support any of the allowed formats, an error is thrown
 *    // and the request is aborted.
 *    ///
 *   allowedCredentialFormats?: SupportedCredentialFormats[]
 * 
 *   /////
 *    // A list of allowed proof of possession signature algorithms in order of preference.
 *    //
 *    // Note that the signature algorithms must be supported by the wallet implementation.
 *    // Signature algorithms that are not supported by the wallet will be ignored.
 *    //
 *    // The proof of possession (pop) signature algorithm is used in the credential request
 *    // to bind the credential to a did. In most cases the JWA signature algorithm
 *    // that is used in the pop will determine the cryptographic suite that is used
 *    // for signing the credential, but this not a requirement for the spec. E.g. if the
 *    // pop uses EdDsa, the credential will most commonly also use EdDsa, or Ed25519Signature2018/2020.
 *    ///
 *   allowedProofOfPossessionSignatureAlgorithms?: JwaSignatureAlgorithm[]
 * 
 *   /////
 *    // A function that should resolve a verification method based on the options passed.
 *    // This method will be called once for each of the credentials that are included
 *    // in the credential offer.
 *    //
 *    // Based on the credential format, JWA signature algorithm, verification method types
 *    // and did methods, the resolver must return a verification method that will be used
 *    // for the proof of possession signature.
 *    ///
 *   proofOfPossessionVerificationMethodResolver: ProofOfPossessionVerificationMethodResolver
 * }
 * @param {string} agent_key
 * @param {string} issuerUri - mandatory: string
 * @param {boolean} verifyCredentialStatus - mandatory: boolean
 * @param {string} allowedCredentialFormats - optional SupportedCredentialFormats[]
 * @param {string} allowedProofOfPossessionSignatureAlgorithms - optional: JwaSignatureAlgorithm[]
 * @param {string} proofOfPossessionVerificationMethodResolver - mandatory: ProofOfPossessionVerificationMethodResolver
 * @returns {Promise.<string>}
 */
export async function jsa_aries_agent_openId4VcClient_requestCredentialUsingPreAuthorizedCode(agent_key, issuerUri, verifyCredentialStatus, allowedCredentialFormats, allowedProofOfPossessionSignatureAlgorithms, proofOfPossessionVerificationMethodResolver) {
	// BEGIN USER CODE
	try{
		if(agent_key==null)return Promise.reject("Invalid agent_key parameter");
		if(issuerUri==null)return Promise.reject("Invalid issuerUri parameter");
		if(verifyCredentialStatus==null)return Promise.reject("Invalid verifyCredentialStatus parameter");
		if(allowedCredentialFormats==null);/*return Promise.reject("Invalid allowedCredentialFormats parameter");*/
		if(allowedCredentialFormats!=null){
			try{
				allowedCredentialFormats=JSON.parse(allowedCredentialFormats);
			}catch(e){
				return Promise.reject("Argument allowedCredentialFormats is not a valid JSON value");
			}
			if(!Array.isArray(allowedCredentialFormats)){
				return Promise.reject("Argument allowedCredentialFormats is not a valid JSON array");
			}
			let allowedCredentialFormats_=[];
			for(let i=0;i<allowedCredentialFormats.length;i++){
				switch(allowedCredentialFormats[i]){
  					case"Jwt":
						allowedCredentialFormats_.push(ClaimFormat.Jwt);
						break;
  					case"JwtVc":
						allowedCredentialFormats_.push(ClaimFormat.JwtVc);
						break;
  					case"JwtVp":
						allowedCredentialFormats_.push(ClaimFormat.JwtVp);
						break;
  					case"Ldp":
						allowedCredentialFormats_.push(ClaimFormat.Ldp);
						break;
  					case"LdpVc":
						allowedCredentialFormats_.push(ClaimFormat.LdpVc);
						break;
  					case"LdpVp":
						allowedCredentialFormats_.push(ClaimFormat.LdpVp);
						break;
					default:return Promise.reject("Invalid allowedCredentialFormats value");
				}
			}
			allowedCredentialFormats=allowedCredentialFormats_;
		}
		if(allowedProofOfPossessionSignatureAlgorithms==null);/*return Promise.reject("Invalid allowedProofOfPossessionSignatureAlgorithms parameter");*/
		if(allowedProofOfPossessionSignatureAlgorithms!=null){
			try{
				allowedProofOfPossessionSignatureAlgorithms=JSON.parse(allowedProofOfPossessionSignatureAlgorithms);
			}catch(e){
				return Promise.reject("Argument allowedProofOfPossessionSignatureAlgorithms is not a valid JSON value");
			}
			if(!Array.isArray(allowedProofOfPossessionSignatureAlgorithms)){
				return Promise.reject("Argument allowedProofOfPossessionSignatureAlgorithms is not a valid JSON array");
			}
			let allowedProofOfPossessionSignatureAlgorithms_=[];
			for(let i=0;i<allowedProofOfPossessionSignatureAlgorithms.length;i++){
				switch(allowedProofOfPossessionSignatureAlgorithms[i]){
					case"HS256":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.HS256);
						break;
					case"HS384":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.HS384);
						break;
					case"HS512":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.HS512);
						break;
					case"RS256":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.RS256);
						break;
					case"RS384":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.RS384);
						break;
					case"RS512":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.RS512);
						break;
					case"ES256":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.ES256);
						break;
					case"ES384":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.ES384);
						break;
					case"ES512":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.ES512);
						break;
					case"PS256":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.PS256);
						break;
					case"PS384":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.PS384);
						break;
					case"PS512":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.PS512);
						break;
					case"EdDSA":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.EdDSA);
						break;
					case"none":
						allowedProofOfPossessionSignatureAlgorithms_.push(JwaSignatureAlgorithm.None);
						break;
					default:return Promise.reject("Invalid allowedProofOfPossessionSignatureAlgorithms value");
				}
			}
			allowedProofOfPossessionSignatureAlgorithms=allowedProofOfPossessionSignatureAlgorithms_;
		}
		if(proofOfPossessionVerificationMethodResolver==null)return Promise.reject("Invalid proofOfPossessionVerificationMethodResolver parameter");



		try{
			proofOfPossessionVerificationMethodResolver=JSON.parse(proofOfPossessionVerificationMethodResolver);
		}catch(e){
			return Promise.reject("Argument proofOfPossessionVerificationMethodResolver is not a valid JSON value");
		}
		let agent=support.cache.get(agent_key);
		if(agent==null)return Promise.reject("Agent not found in cache");
		let options={};
		if(issuerUri!=null)options.issuerUri=issuerUri;
		if(verifyCredentialStatus!=null)options.verifyCredentialStatus=verifyCredentialStatus;
		if(allowedCredentialFormats!=null)options.allowedCredentialFormats=allowedCredentialFormats;
		if(allowedProofOfPossessionSignatureAlgorithms!=null)options.allowedProofOfPossessionSignatureAlgorithms=allowedProofOfPossessionSignatureAlgorithms;
		if(proofOfPossessionVerificationMethodResolver!=null)options.proofOfPossessionVerificationMethodResolver=proofOfPossessionVerificationMethodResolver;
		return Promise.resolve(JSON.stringify(await agent.modules.openId4VcClient.requestCredentialUsingPreAuthorizedCode(options)));
		/*
TypeError: r.allowedProofOfPossessionSignatureAlgorithms.filter is not a function. (In 'r.allowedProofOfPossessionSignatureAlgorithms.filter(function(e){return o.includes(e)})', 'r.allowedProofOfPossessionSignatureAlgorithms.filter' is undefined)

Nanoflow stack:
 "Call JavaScript Action" in nanoflow "AriesTestHarness.nf_openid4vc_test"

 TypeError: r.allowedProofOfPossessionSignatureAlgorithms.filter is not a function. (In 'r.allowedProofOfPossessionSignatureAlgorithms.filter(function(e){return o.includes(e)})', 'r.allowedProofOfPossessionSignatureAlgorithms.filter' is undefined)

Nanoflow stack:
 "Call JavaScript Action" in nanoflow "AriesTestHarness.nf_openid4vc_test"
 */
	}catch(e){
		return Promise.reject(e.toString());
	}
	// END USER CODE
}
